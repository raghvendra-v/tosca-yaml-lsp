/*
 * generated by Xtext 2.18.0
 */
package org.ezyaml.lang.tosca.jvmmodel

import com.google.inject.Inject
import org.eclipse.xtext.common.types.JvmDeclaredType
import org.eclipse.xtext.common.types.JvmTypeReference
import org.eclipse.xtext.xbase.jvmmodel.AbstractModelInferrer
import org.eclipse.xtext.xbase.jvmmodel.IJvmDeclaredTypeAcceptor
import org.eclipse.xtext.xbase.jvmmodel.JvmTypesBuilder
import org.ezyaml.lang.tosca.yaml.Scalar
import org.ezyaml.lang.tosca.yaml.ToscaSuperTypeDeclaration
import org.ezyaml.lang.tosca.yaml.ToscaType
import org.ezyaml.lang.tosca.yaml.ToscaTypeMembers
import org.ezyaml.lang.tosca.yaml.YamlMappingEntry
import org.ezyaml.lang.tosca.yaml.YamlRHS
import org.ezyaml.lang.tosca.common.CatalogueResourceURI
import org.eclipse.xtext.xbase.services.XtypeGrammarAccess.JvmParameterizedTypeReferenceElements

/**
 * <p>Infers a JVM model from the source model.</p> 
 * 
 * <p>The JVM model should contain all elements that would appear in the Java code 
 * which is generated from the source model. Other models link against the JVM model rather than the source model.</p>     
 */
class YamlJvmModelInferrer extends AbstractModelInferrer {

	/**
	 * convenience API to build and initialize JVM types and their members.
	 */
	@Inject extension JvmTypesBuilder

	/**
	 * The dispatch method {@code infer} is called for each instance of the
	 * given element's type that is contained in a resource.
	 * 
	 * @param element
	 *            the model to create one or more
	 *            {@link JvmDeclaredType declared
	 *            types} from.
	 * @param acceptor
	 *            each created
	 *            {@link JvmDeclaredType type}
	 *            without a container should be passed to the acceptor in order
	 *            get attached to the current resource. The acceptor's
	 *            {@link IJvmDeclaredTypeAcceptor#accept(org.eclipse.xtext.common.types.JvmDeclaredType)
	 *            accept(..)} method takes the constructed empty type for the
	 *            pre-indexing phase. This one is further initialized in the
	 *            indexing phase using the lambda you pass as the last argument.
	 * @param isPreIndexingPhase
	 *            whether the method is called in a pre-indexing phase, i.e.
	 *            when the global index is not yet fully updated. You must not
	 *            rely on linking using the index if isPreIndexingPhase is
	 *            <code>true</code>.
	 */
	def dispatch void infer(ToscaType element, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
		acceptor.accept(element.toClass(element.name)) [
			// annotations += annotationRef(CatalogueResourceURI, element.eResource.URI.toString)
			superTypes +=
				element.entries.filter(ToscaSuperTypeDeclaration)?.map[superType.name]?.map[typeRef(it)].
					findFirst[true].cloneWithProxies
			var description = (element.entries.filter(YamlMappingEntry).findFirst[key === "description"]?.
				value as Scalar)?.stringValue
			description = if (description !== null)
				description + ". Specified in : " + element.eResource.URI + " ."
			else
				description = "Specified in : " + element.eResource.URI + " ."
			documentation = description
			for (m : element.entries.filter(ToscaTypeMembers).map[entries].flatten) {
				var JvmTypeReference typeref = null
				val propValues = m.value.filter(YamlRHS)?.map[entries].flatten.filter(YamlMappingEntry)
				var type = propValues?.filter[key == "type"]?.map[value]?.flatten.filter(Scalar)?.findFirst[true]?.
					stringValue?.trim()
				var required = propValues?.filter[key == "required"]?.map[value]?.flatten.filter(Scalar)?.findFirst [
					true
				]?.boolValue?.trim()
				var status = propValues?.filter[key == "status"]?.map[value]?.flatten.filter(Scalar)?.findFirst[true]?.
					stringValue?.trim()
				var entry_schema = propValues?.filter[key == "entry_schema"]?.map[value].flatten.filter(YamlRHS).map [
					entries
				].flatten.filter(YamlMappingEntry).filter[key == "type"].map[value].flatten.filter(Scalar)?.map [
					getNormalizedType(stringValue?.trim())
				].toList
				var _default = propValues?.filter[key == "default"]?.map[value]?.flatten.filter(Scalar)?.
					findFirst[true]?.stringValue?.trim()
				var constraints = propValues?.filter[key == "constraints"]?.map[value]?.flatten.filter(Scalar)?.
					findFirst[true]?.stringValue?.trim()

				typeref = getNormalizedType(type)
				if (entry_schema !== null && entry_schema.size > 0) {
					if (typeref.qualifiedName == "java.util.Map" && entry_schema.size == 1) {
						entry_schema.add(0, getNormalizedType('java.lang.String'))
					}
					typeref = typeRef(typeref.qualifiedName, entry_schema).cloneWithProxies
				}
				members += m.toField(m.key, typeref) [
					documentation = propValues?.filter[key == "description"]?.map[value]?.flatten.filter(Scalar)?.
						findFirst[true]?.stringValue?.trim()
				]
			}
		]
	}

	def private JvmTypeReference getNormalizedType(String typeString) {
		var type = typeRef('java.lang.Object')
		if (typeString !== null) {
			type = {
				switch typeString {
					case 'string':
						typeRef('java.lang.String')
					case typeString.matches('integer|int'):
						typeRef("java.lang.Integer")
					case 'list':
						typeRef("java.util.List")
					case 'map':
						typeRef("java.util.Map")
					default:
						typeRef(typeString)
				}
			}
		}
		type.cloneWithProxies
	}
}
